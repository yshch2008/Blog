领域建模
## 面向对象
抽象：把复杂的问题通过抽象简单化，为具体的问题找到最恰当的类的定义，并在最合适的继承级别找到解决的方案。

组合：对象可以在实例变量中包含其他对象

人们希望编程是更加灵活更加符合人类思维方式的，面向对象编程本质可以看成是由各种独立而互相调用的对象组成的程序，而且事实证明，面向对象确实比过程式更加灵活，更加容易维护。
那么，从起床这个问题来看，起床的内部实现其实还是面向过程式的，即使用的还是面向对象编程去实现，所以，我个人觉得面向对象是相对的，需要站在解决问题的角度来看待面向对象的抽象层次，与之对于的过程式编程是在不同的层次解决不同的问题，其他编程范式也一样，它们之间可以并存，这并不矛盾。

## S.O.L.I.D设计原则
### 单一职责原则（Single responsibility principle）
一个类或则一个模块应当只有一种职责，其提供的服务应该与其责任保持一致，如果存在多种责任则应考虑对其拆分。

### 开闭
软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的
开闭原则主要思想就是对于扩展的包含，对于修改的限制，新增功能的同时避免修改已有的实现，尽量做到对外提供的功能不变

### 里氏替换原则（Liskov substitution principle）

程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的

里氏替换原则认为子类的功能应该可以完全替换父类并且不会影响程序的正确性，简单理解就是子类在继承父类的同时不能改变父类已有的功能，加上开闭原则子类只能对父类进行扩展而不能对父类的功能进行修改。

### 接口隔离原则（Interface segregation principle,ISP）
多个特定功能接口要好于一个宽泛用途的接口

接口隔离强调将大而全的接口拆分成小而精的接口，使用方只需关系自己需要的接口，通过接口隔离有利于系统的解耦，增加程序的易用性和拓展性。

### 依赖反转原则（Dependency inversion principle,DIP）

1.高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口
2.抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口

依赖反转原则是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。


### 一、贫血模型

所谓贫血模型，是指Model 中，仅包含状态(属性），不包含行为(方法），采用这种设计时，需要分离出DB层，专门用于数据库操作。

### 二、充血模型

Model 中既包括状态，又包括行为，是最符合面向对象的设计方式。

 


## JDK 1.8 新特性
1. lambda ：本质上是一段匿名内部类，也可以是一段可以传递的代码
2. stream
3. 函数式接口
4. *方法引用和构造器调用
5. 接口中的默认方法和静态方法：在接口中可以使用default和static关键字来修饰接口中定义的普通方法
6. 新时间日期API ：LocalDate | LocalTime | LocalDateTime
7. ConcurrentHashMap (锁分段机制)，concurrentLevel,jdk1.8采用CAS算法(无锁算法，不再使用锁分段)，数组+链表中也引入了红黑树的使用

### Stream API
###  创建
``` java
    // 1，校验通过Collection 系列集合提供的stream()或者paralleStream()
    List<String> list = new ArrayList<>();
    Strean<String> stream1 = list.stream();
```
### 中间操作
``` java
/**
   * 筛选 过滤  去重
   */
  emps.stream()
          .filter(e -> e.getAge() > 10)
          .limit(4)
          .skip(4)
          // 需要流中的元素重写hashCode和equals方法
          .distinct()
          .forEach(System.out::println);
```
### 终止
``` java
         *      查找和匹配
         *          allMatch-检查是否匹配所有元素
         *          anyMatch-检查是否至少匹配一个元素
         *          noneMatch-检查是否没有匹配所有元素
         *          findFirst-返回第一个元素
         *          findAny-返回当前流中的任意元素
         *          count-返回流中元素的总个数
         *          max-返回流中最大值
         *          min-返回流中最小值
         
```
## Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。 
关键字：递归分合、分而治之。 
采用 “工作窃取”模式（work-stealing）： 
当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线 
程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中 
相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的 
处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因 
无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果 
某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子 
问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程 
的等待时间,提高了性能.。

## 新的时间API
* 之前使用的java.util.Date月份从0开始，我们一般会+1使用，很不方便，java.time.LocalDate月份和星期都改成了enum
 * java.util.Date和SimpleDateFormat都不是线程安全的，而LocalDate和LocalTime和最基本的String一样，是不变类型，不但线程安全，而且不能修改。
 * java.util.Date是一个“万能接口”，它包含日期、时间，还有毫秒数，更加明确需求取舍
 * 新接口更好用的原因是考虑到了日期时间的操作，经常发生往前推或往后推几天的情况。用java.util.Date配合Calendar要写好多代码，而且一般的开发人员还不一定能写对。