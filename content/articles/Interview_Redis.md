## 与memcached区别
|redis|memcached|
|---|---|
|快照/AOF持久化到硬盘|只能在内存里|
|k-v,list,string,hash,set,zset|只有KV|
|支持虚拟内存，将一部分值放到硬盘上|不能超过内存大小|
|储存数据|可以缓存图片文件等|
|有数据结构，支持一些运算过滤等|只是简单的cache|
|单线程，性能差一些|能利用多线程，性能更好，达到几十万QPS|

## 缓存雪崩
缓存雪崩是指在我们设置缓存失效时间上时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部打到后端数据库，数据库一时请求过大,数据库cpu和IO一时负载过大,造成雪崩。

### 解决方案
1. 限流，设置滑动窗口，保证同一时刻不会有大量请求被递交到数据库
2. 排队，让并发变成串行
3. 布隆过滤器：牺牲正确率，提升判断速度（某元素是否存在于某集合）
4. 二级缓存，设置一个大容量，生命周期更长的缓存，常规redis挂了就来访问这个

## 缓存穿透

大量的请求在缓存中没有命中,导致每次都要到数据库里面去查询,这样导致缓存被穿透.

### 解决方案
1. 防恶意：网关等处设置IP过滤，比如限制每个IP每秒只有5个请求有效
2. 以其申请的Key 创建对象，这样无效key第二次就会走缓存通道
3. 限流窗口
4. 为不命中的请求建立一个map，key为ip，key为自增的次数，发生不命中的时候判断一下次数，判断是不是恶意的，然后加黑名单

## 缓存预热
在系统正式使用之前，把相关数据线记载到缓存里，这样系统开始运行之后已经有一部分请求会从缓存里获得了，用户体验和数据库安全都有提升。
类似于线程池对核心线程进行预热。

## 降级
判断发生故障时，使用软硬方式熔断。

## redis事务
Redis 通过 MULTI 、 DISCARD 、 EXEC 和 WATCH 四个命令来实现事务功能——不可嵌套

### Multi -Exec
维护如Multi后开启事务模式，后面的请求会被pending，直到输入Exec，把这些pending的请求按一个事务处理

### Discard
取消一个事务，清空客户端的整个事务队列，并让事务模式退回非事务模式

### Watch
只能在非事务状态下执行，否则会收到一个错误
用于在事务开始之前监视某些键，当调用Exec命令执行事务时，如果监视的键被其他客户端修改了，那么整个事务不在执行，返回失败。
判断使用CAS乐观锁

### Unwatch
清除掉本次事务所监控的键，也就是忽略那些键是否发生修改。

## 集群方式
#### 1.主从模式
主节点负责写入，从节点负责读取，保证一致性，依赖主节点的可用性。

#### 2.哨兵模式
在主从模式基础上加一个哨兵机制，监控主节点状态，挂掉就在剩余节点里选一个作为新的主节点。

#### 3.集群模式
每个节点都是主节点，数据分布存储，节点之间数据不一致。

## 持久化
### 1.RDB
把数据写到文件中，后面可以从文件恢复数据。
如果redis发生更新，但是还没有写入文件，那么这时候发生故障，这些更新会丢失。
使用单独子线程执行持久化，不影响主线程的性能表现。
可以设置每间隔一段时间执行一次，或是自上一次持久化后累计发生多少次更新 后持久化，如果都设置了，那么要等待两个条件都满足才执行。
也可以在客户端用命令手动持久化
`./redis-cli -h ip -p port save`
`./redis-cli -h ip -p port bgsave`
优先级低于AOF

### 2.AOF

将写入动作以及对应数据 保存到日志文件中，这样还原时相当于把以前所有更新都重新跑一遍，达到恢复的目的。
AOF文件内容是字符串，可读性好 。
间隔可以设置更小，保存的粒度会更小，那么故障时损失的更新也更少。

恢复速度慢
占用空间多

`AOF默认关闭，开启方法，修改配置文件reds.conf： appendonly yes`

### Redis同步问题

#### 1.旧版
SYNC命令是一个非常耗费资源的操作

每次执行SYNC命令,主从服务器需要执行以下动作:

主服务器需要执行BGSAVE命令来生成RDB文件,这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。
主服务器需要将自己生成的RDB文件发送给从服务器,这个发送操作会耗费主从服务器大量的网络资源(带宽和流量),并对主服务器响应命令请求的时间产生影响。
接收到RDB文件的从服务器需要载入主服务器发来的RDB文件,并且在载入期间,从服务器会因为阻塞而没办法处理命令请求。
因为SYNC命令是一个如此耗费资源的操作,所以Redis有必要保证在真正有需要时才执行SYNC命令。

#### 2.PSYNC
PSYNC命令具有完整重同步( full resynchronization)和部分重同步( partial resynchronization)两种模式,

其中完整重同步用于处理初次复制情况:完整重同步的执行步骤和SYNC命令的执行步骤基本一样,它们都是通过让主服务器创建并发送RDB文件,以及向从服务器发送保存在缓冲区里面的写命令来进行同步。
而部分重同步则用于处理断线后重复制情况:当从服务器在断线后重新连接主服务器时,如果条件允许,主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器,从服务器只要接收并执行这些写命令,就可以将数据库更新至主服务器当前所处的状态。

##### 2.3 复制积压缓冲区
复制积压缓冲区是由主服务器维护的一个固定长度(fixed-size )先进先出( FIFO )队列,默认大小为1MB。

当主服务器进行命令传播时,它不仅会将写命令发送给所有从服务器 还会将写命令人 队到复制积压缓冲区里面 。

因此,主服务器的复制积压缓冲区里面会保存着一部分最近传播的写命令,并且复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量 。

- 当从服务器重新连上主服务器时,从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器,主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：
- 如果offset偏移量之后的数据(也即是偏移量offset+1开始的数据)仍然存在于复制积压缓冲区里面、那么主服务器将对从服务器执行部分重同步操作。
相反,如果offset偏移量之后的数据已经不存在于复制积压缓冲区,那么主服务器将对从服务器执行完整重同步操作。

#### 2.4 服务器运行ID
除了复制偏移量和复制积压穿冲区之外，实现部分重同步还需要用到服务器运行ID：

每个Redis服务器,不论主服务器还是从服务,都会有自己的运行ID。
运行ID在服务器启动时自动生成,由40个随机的十六进制字符组成。
当从服务器对主服务器进行初次复制时,主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来。

当从服务器断线并重新连上一个主服务器时,从服务器将向当前连接的主服务器发送之1前保存的运行ID：

如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同,那么说明从服务器断线之前复制的就是当前连接的这个主服务器,主服务器可以继续尝试执行部分重同步操作。
相反地,如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同,那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器,主服务器将对从服务器执行完整重同步操作。


### 高效的原因
1. 基于内存
2. 单线程，没有锁和上下文切换开销
3. IO多路复用，使用单个线程处理多个Socket请求，epoll-select