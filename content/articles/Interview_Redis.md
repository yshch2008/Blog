## 与memcached区别
|redis|memcached|
|---|---|
|快照/AOF持久化到硬盘|只能在内存里|
|k-v,list,string,hash,set,zset|只有KV|
|支持虚拟内存，将一部分值放到硬盘上|不能超过内存大小|
|储存数据|可以缓存图片文件等|
|有数据结构，支持一些运算过滤等|只是简单的cache|
|单线程，性能差一些|能利用多线程，性能更好，达到几十万QPS|

## 缓存雪崩
缓存雪崩是指在我们设置缓存失效时间上时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部打到后端数据库，数据库一时请求过大,数据库cpu和IO一时负载过大,造成雪崩。

### 解决方案
1. 限流，设置滑动窗口，保证同一时刻不会有大量请求被递交到数据库
2. 排队，让并发变成串行
3. 布隆过滤器：牺牲正确率，提升判断速度（某元素是否存在于某集合）
4. 二级缓存，设置一个大容量，生命周期更长的缓存，常规redis挂了就来访问这个

## 缓存穿透

大量的请求在缓存中没有命中,导致每次都要到数据库里面去查询,这样导致缓存被穿透.

### 解决方案
1. 防恶意：网关等处设置IP过滤，比如限制每个IP每秒只有5个请求有效
2. 以其申请的Key 创建对象，这样无效key第二次就会走缓存通道
3. 限流窗口
4. 为不命中的请求建立一个map，key为ip，key为自增的次数，发生不命中的时候判断一下次数，判断是不是恶意的，然后加黑名单

## 缓存预热
在系统正式使用之前，把相关数据线记载到缓存里，这样系统开始运行之后已经有一部分请求会从缓存里获得了，用户体验和数据库安全都有提升。
类似于线程池对核心线程进行预热。

## 降级
判断发生故障时，使用软硬方式熔断。

## redis事务
Redis 通过 MULTI 、 DISCARD 、 EXEC 和 WATCH 四个命令来实现事务功能——不可嵌套

### Multi -Exec
维护如Multi后开启事务模式，后面的请求会被pending，直到输入Exec，把这些pending的请求按一个事务处理

### Discard
取消一个事务，清空客户端的整个事务队列，并让事务模式退回非事务模式

### Watch
只能在非事务状态下执行，否则会收到一个错误
用于在事务开始之前监视某些键，当调用Exec命令执行事务时，如果监视的键被其他客户端修改了，那么整个事务不在执行，返回失败。
判断使用CAS乐观锁

### Unwatch
清除掉本次事务所监控的键，也就是忽略那些键是否发生修改。

## 集群方式
#### 1.主从模式
主节点负责写入，从节点负责读取，保证一致性，依赖主节点的可用性。

#### 2.哨兵模式
在主从模式基础上加一个哨兵机制，监控主节点状态，挂掉就在剩余节点里选一个作为新的主节点。

#### 3.集群模式
每个节点都是主节点，数据分布存储，节点之间数据不一致。

## 持久化
### 1.RDB
把数据写到文件中，后面可以从文件恢复数据。
如果redis发生更新，但是还没有写入文件，那么这时候发生故障，这些更新会丢失。
使用单独子线程执行持久化，不影响主线程的性能表现。
可以设置每间隔一段时间执行一次，或是自上一次持久化后累计发生多少次更新 后持久化，如果都设置了，那么要等待两个条件都满足才执行。
也可以在客户端用命令手动持久化
`./redis-cli -h ip -p port save`
`./redis-cli -h ip -p port bgsave`
优先级低于AOF

### 2.AOF

将写入动作以及对应数据 保存到日志文件中，这样还原时相当于把以前所有更新都重新跑一遍，达到恢复的目的。
AOF文件内容是字符串，可读性好 。
间隔可以设置更小，保存的粒度会更小，那么故障时损失的更新也更少。

恢复速度慢
占用空间多

`AOF默认关闭，开启方法，修改配置文件reds.conf： appendonly yes`