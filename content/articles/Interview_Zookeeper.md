
### 10.zookeeper的基本原理，实现分布式锁、自增节点、唯一key、watch机制等
#### 1.zookeeper的基本原理
  1. zk 一般由多个节点构成（单数），采用 zab 一致性协议。因此可以将 zk 看成一个单点结构，对其修改数据其内部自动将所有节点数据进行修改而后才提供查询服务。
  2. zk 的数据以目录树的形式，每个目录称为 znode， znode 中可存储数据（一般不超过 1M），还可以在其中增加子节点。

#### 角色
|角色||描述|
|---|---|---|
|Leader||负责发起投票和对投票结果决议，更新系统状态|
|Leaner|Follower|对客户端提供服务，参与选举|
|Leaner|Observer|可以客户端请求转发给Leader，不参与投票|
|Client||服务的消费者|

#### 子节点有三种类型。
  1. 序列化节点，每在该节点下增加一个节点自动给该节点的名称编号自增。
  2. 临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除。
  3. 普通节点。

#### 队列管理

#### 自增节点
  
#### watch机制：
客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。

#### ZK实现分布式锁
##### 1. 基本锁
1. 利用临时节点与watch机制，需要获取锁的时候就新建相对应的临时节点，创建成功代表获取锁成功，失败则watch该节点，接到通知临时节点已经删除后再重新竞争这个锁。

缺点：一起watch，一起接到可以重新竞争的通知，就会一起去尝试获取锁，引起大量并发

2. 上锁时不使用临时节点而是使用序列化节点，每个锁放在一个普通节点上，每个上锁的操作都要在相应的节点下创建序列化节点，只有持有当前最小编号的节点可以拥有锁，竞争失败的客户需要去watch前一个序号的节点，使用完毕之后删除自己的节点。

比redis方式好在哪？不用设计占有时间，因为这个时间会导致资源有的时候是空闲的但无法被消费，造成浪费。

2. 分布式锁：当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。保证同一个方法在同一时间只能被一台机器上的一个线程执行。
  1. 本质还是保持每个操作的独立性，在分布式场景下可以利用数据库或者redis实现，利用数据库操作比较麻烦而且增加数据库负载，因此推荐用redis实现：
  2. 给资源编排目录
  3. 每个资源都有一个记录存放 当前锁的状态和此时持有锁的机器编号以及线程号，为了保证出现意外资源一直得不到释放，还要存放超时时间
  4. 每个操作尝试获取资源之前，需要先从redis拿到资源的状态，可用的话就去更新redis里面的状态，成功则开始执行操作
  5. 执行期间要判断自己设置的过期时间是不是快到了，如果还没执行完需要及时续费
  6. 操作执行完毕是要去redis更新这个资源的状态，把锁释放掉
  7. 如果某个持有锁的操作意外终止没有及时释放锁，可以根据锁的过期时间判断是不是可以尝试获取锁
  8. 在项目中实际使用过，保证对数据库操作的并发量低于200


#### 数据服务与数据复制
##### 1. 容错性更好
某节点坏了别的节点可以代替它继续工作；提高负载能力
##### 2. 提高负载能力
把负载分布到多个节点上，可以通过增加节点提供更高的负载能力
##### 5. 性能更好
客户端可以选择访问离自己近的节点，访问速度会更快

#### ZK常用指令
`create` path data ——创建节点目录，并附加初始数据
`stat` node ——查看节点状态
