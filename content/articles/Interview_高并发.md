## java.util.concurrent
原理就是volatile语义和CAS操作

### 1. HashMap原理：set get过程，rehash过程等，HashMap的缺陷，HashMap的JDK8实现原理，
顶层是数组，每个元素叫一个tab，tab以链表的形式存储实际键值对Entry
先用key的hash值对数组长度模运算取余数，确定将存在哪个tab，然后加到tab中链表的尾部
如果已经保存的元素总数处以hashmap的容量大于负载因子，则rehash
rehash时先创建一个容量更大的数组，然后逐个取出原来存储的元素，经过重新对hashcode取模，依次放到新的hashmap中合适的位置
缺陷：不是线程安全的类型

JDK 8:链表长度超过8时转化为红黑树，在hash冲突比较多时依然能保持性能
扩容时申请的大小是之前的两倍，这样元素要么还在原来的位置上，要么移动原先数组的长度到另一个位置，也就是只要判断hashcode高位是0还是1就可以了，省去重新计算位置的操作。
并且这样处理，元素会比较均匀的分散开来，让链表长度更小

### ConcurrentHashMap实现原理
每个tab上带有一个锁
修改这个tab里面的元素时会对整个tab加锁，这样保证修改是线程安全的
// 如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树

### Java线程池实现原理，线程池构的几个主要参数
  1. corePoolSize没有满，则new线程执行任务（可以使用prestartCoreThread/all提前建满核心线程）
  2. corePoolSize满了，新来的任务会存在阻塞队列，当阻塞队列长度小于corePoolSize时，不新建线程，而是等coreThread空闲时分配
  3. (有界)阻塞队列长度加上corePoolSize应小于等于maxPoolSize，阻塞满了之后会创建新的线程执行任务
  3. （无界）则不存在阻塞队列满的情况，那么只是机械的阻塞新任务，核心线程不断从阻塞队列中取出并执行任务
  4. 线程池中工作的线程数量已经等于maxPoolSize，而阻塞队列又满了，再接到新任务，则执行拒绝策略
  4. 拒绝策略：默认抛异常，忽略请求，替换掉执行时间最长的任务，放入队列等待call

### wait，sleep区别。
1. sleep()方法让线程暂停执行指定的时间，让出CPU给其他线程，但保留已获取的锁，不推荐
2. wait()导致当前线程进入waiting状态，直到请求的对象执行notify/notifyAll操作，释放获取的锁
3. yield()

### 重入锁，读写锁，实现原理
1. 重入锁表示该线程获得锁后，内部的再次获得该锁的操作会被允许，原理：锁状态标记在被获得或者重入时加一，每次释放减一，为零时表示可以被获得，否则表示被锁。
2. 读写锁主要解决的是多线程场景下读写互斥的问题，读和读操作不互斥，写操作会给资源上锁，有锁时既不能读也不能写。原理：执行写操作时会先获取写锁，写锁被某个线程获取期间，所有其他线程的读写请求都会被阻塞直到该写锁被释放。


### 悲观锁，乐观锁，CAS
1. 悲观锁：在操作进行之前就先把资源上锁，在整个使用期间都是排他的
2. 乐观锁：只是在提交修改的时候判断一下资源的状态是否符合预期，符合的话就提交，不符合就撤回，在此期间其他线程依然同样有着对资源的访问权，因此在读请求量大的时候有相当优秀的性能
3. CAS ：尝试更新一个值得时候，用期望值对比内存中的实际值，如果相同则认为没有发生预料之外的修改，提交更新操作，否则放弃提交。因为是CPU级别的实现，性能比较好。


#### synchronized和volatile各自什么使用场景，两者什么区别
1. synchronized 是重量级锁，主要解决的是资源竞争问题，被修饰的代码块也不会发生指令的重排，有原子性的特点，实现的手段是对象头中的标记信息
2. volatile 主要解决的是线程操作可见性的问题，被修饰的变量会反应到内存值/根源值上 ，但是不保证原子性，实现手段是在修改前把值刷新到内存，使其修改对其他线程是可见的


### 生产者消费者的高并发实现。
1. 使用Blockqueue
2. 设定先进先出的缓冲队列，用于存放商品
3. 队列为空时，消费者不消费；满时，生产者不添加
4. 生产者和消费者在尝试活动时都会先判断队列的锁的状态，获取成功才进行相应的操作，否则等待锁
