

### 4.MySQL分库分表，规则，考虑，如何实现，维度问题、新老库表扩容问题
单库5000万 以内性能比较好
单表500万以下
#### 纵向切分：
1. 拆库 ：根据关联性，把关联性弱的表存到不同的数据库，每个功能模块或者服务根据需要访问不同数据
2. 拆表： 
将使用频率不高的字段或者内容比较多的字段拆到其他表中，在字段多的时候，这样拆可以让维护工作更容易进行，同时因为每行的占用空间减小了，减少跨页开销。对常用字段来说，单行数据减少，内存可以加载更多行的数据，命中效率会更好。
#### 横向拆分
类似于hashmap存储的思想
按照某个维度上的映射规则判断一条数据应该放在哪张分页里，可以有效减少单表数据量

#### 问题：
垂直：每次提交update，要建立多个事务，控制起来更麻烦
join操作很多会失效,被拆分的列之间的联系需要手动维持

#### 规则/维度：
##### 水平拆分：
1. 如果选定的维度字段没有特殊含义，是自增来的，那么直接按模运算映射即可
2. 如果这个维度里包含一些有价值的信息，或者叫子维度，那么尽量照顾到这些规则的使用价值，例如身份证号码也是ID，但是包含很多附加信息，如地区，年龄等，拆分的时候尽量考虑到这些信息
3. 如果另外一个维度也有很高的使用价值，那么可以考虑按每个维度做一次拆分，数据按每个维度存一份，用空间换时间
4. 避免出现跨多个库的事件
5. 按照某个维度划分后的数据出现分组，那么相同分组的数据尽量存在同一个服务器上，例如用户按照年龄层划分好后，用户相关的信息如信用信息，教育信息有都会有分组，同个分组的数据尽量靠近

##### 扩容问题
1. 按照时间参数分库的，不需要进行规则的变化和数据的迁移，比如前一百万个存在表1，没增加一百万个就新增一个表。但是时间分库没有解决写入操作的并发量问题，因为新增的数据总是在同一个库。

2. 可以参考1.8之后hashmap 的扩容，模运算的因子扩大成2倍



#### 6. SQL如何优化
1. 在经常使用作为查找条件where或者排序依据order by的字段上建立索引
2. 不在条件中判断null ，否则会导致索引失效
3. 不使用 <> 或者！= 这种非 判断
4. or链接的条件上，没有索引的会导致有索引的也失效
5. not in 和in 这种范围查询 exsists代替in
6. like查询
7. 条件where里面使用参数，——SQL只有在运行时才会解析变量，但优化程序不能讲访问计划推迟到运行时，编译时变量是未知的，无法选为索引——可以使用强制索引
8. 函数操作，例如字符串的切割拼接等
9. 等号左侧进行运算等操作，可能会导致索引失效
10. 复合索引的顺序问题
11. update操作只update 必须要修改的字段
12. join应该在分页后进行，不然要处理大量链接

### 5.mysql四个隔离级别，各自使用场景，幻读是什么，间隙锁是什么
1. 脏读：没有提交的写入事务被其他事务读取到了
2. 不可重复读：两次读取操作之间其他事务提交了写入操作，导致读取的同一条记录的数据是不一样的（默认可重复读）
3. 幻读：两次读取操作之间其他事务提交了插入或者删除操作，导致两次读取的记录是不一样的
4. 丢失更新：两个事务都尝试写，先进行写入的操作可能会被后一个操作覆盖掉
5. 间隙锁：针对查询键值范围内不存在的那些气泡/间隙记录加锁，可以防止幻读

### 6.mysql死锁的解释，如何避免
1. 两个事务都已经锁住了对方需要申请的资源，导致双方的执行条件都不满足，进入循环等待
2. 给表编排访问顺序,程序执行时按照相同的顺序访问表 ；
3. 减少一个事务包含的操作数量；
4. 尽可能做到一次锁定获取该事务所需的全部资源；
5. 升级锁的粒度
6. innodb_lock_wait_timeout ：设置资源的等待超时参数，超过等待时间后还没有成功拿到锁，就撤回


3. SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
4. SELECT * FROM table_name WHERE ... FOR UPDATE
5. 行锁开销大，适合写入
6. 表锁开销小，适合读取
7. <b/> 针对索引上锁，因此没有索引的只能表锁
8. <b/>索引键冲突的话，即使访问不同行的数据，也会冲突


### 7.数据库行锁，表锁，页锁
1. InnoDB默认是行锁，也可以支持表锁
2. 表锁粒度大，但是加锁开销比较小
3. 行锁粒度最小，锁定资源最精确，但是开销比较大
4. 页锁介于二者之间，一次锁定连续的一组记录


### 8.数据库结构B+树大致了解，说清楚索引的过程
1. 包含K个子树的中间结点也包含K个元素
2. 父节点都是其子节点的边界值
3. 节点的元素个数在层数的一半和一倍之间
4. 父节点两两组成范围，每个范围对应一个叶子节点
5. 最左边的父节点单独组成一个负无穷到它自身大小的范围
6. 整棵树形成的集合等于叶子节点的集合
7. 每一个叶子节点的带有指向右边一个叶子节点的指针，因此叶子节点本身形成一个有序的链表，在范围取值和排序时有比较大的优势
8. 到达每一个叶子节点的路径长度都是一样的，性能稳定