
## Java虚拟机：
### 1.垃圾收集算法，分代算法，过程和原理。
1. 新生代中，每次GC都有大批对象死去，因此选用复制算法，无碎片-只需要复制少量存货对象
2. 老年代对象存活率高，使用复制算法要占用大量空间，因此用标记-清理或标记-整理来进行回收
3. ParNEW可以和CMS配合工作，因此是首选的新生代收集器
4. CMS: 第一阶段STW，标记GC-ROOTS对象，然后释放STW，多线程并发标记可达对象，然后再次STW，把并发标记期间发生的改动整理进标记结果，最后释放STW，并发清理垃圾——采用标记清理算法，因此有碎片
5. G1：可以回收两个世代的垃圾，采用分区标记的方式，每个分区维护一个引用表rememberSet，用于记录区域中的引用关系，
6. ZGC：类似分区的分页，可以指定为2/32/自定义大小，第一阶段STW ，标记GC ROOTS，第二阶段，标记可达对象，第三阶段STW ，并行标记期间的改动整理进标记结果；然后 STW 移动ROOT 对象，然后释放STW，并行移动可达对象，（这些引用的更新体现在读屏障，所以程序可以获取），最后把移动了的对象地址更新到栈上

### 2.bug shooting，检验实际线上问题处理
####	如果出现cpu 100%是如何处理 --说清楚使用的一些linux命令。
1. `top`查看CPU占用
2. `top -p PID` top 加进程ID，查看该进程的线程状态
3. `jstack -l PID`jstack 加进程ID ，查看日志
4. `jmap -dump::live,format=b,file=dump.hprof 2927` jmap 加dump 加导出格式等 导出内存镜像
5. 用MAT 等内存分析工具分析

#### 出现oom 内存溢出如何处理  --说清楚使用的一些linux命令。
根据OOM报错信息调整 JVM配置（catalina.bat）



### 3. JVM的常用参数能够清楚说出几个以及背后原理
1. `-Xmx300m` java堆最大值
2. `-Xms300m` java堆初始值，最好将这两个设置相同，避免每次垃圾回收后JVM重新分配内存
3. `-XX:NewRatio=4` 设置年轻代和老年代的比值
4. `-XX:SuervivorRatio=4` 设置两个suvivor区和Eden的比值
5. `XX:MaxPermSize=16m` 设置永生代大小 1.8后已经没有永久代
6. `-XX：MaxMetaspaceSize = 512m` 设置元空间最大容量


### 4.了解处理问题时使用了哪些工具，比如jProfiler，btrace等
#### 1.jProfile   ——基于socket通信
1. 在Linux安装Agent
2. 在windows端安装GUI
3. 设置好连接端口和安装信息等
4. 设置过滤器和触发器
5. 连接agent

可以看到方法调用链信息，堆中的实例信息，JVM内存整体使用情况等信息


### 5.Java内存模型
1. 本地方法栈
2. 运行时常量池
3. 方法区
4. Java栈
5. Java堆
6. 程序计数器


### 类加载器
根据指定全限定名称将class文件加载到JVM内存，转为Class对象
启动类java_home/bin目录 或Xbootclasspath路径中的类库
扩展类Java_home/bin/ext或java.ext.dir系统变量指定的路径中的所有类库
应用程序加载用户路径classpath上的指定类库，可以直接使用

### 类加载顺序
`这样的加载顺序不是绝对的 因为静态变量和静态代码块跟声明顺序有关。`
父类静态属性-》父类静态代码块-》子类静态变量-》子类静态代码块-》父类非静态变量-》父类非静态代码块-》父类构造函数-》子类非静态变量-》子类非静态代码块-》-》子类构造函数

### 双亲委派模型
如果一个类加载器收到类加载的请求，他不会自己尝试去直接加载这个类，而是把这个请求委派给父类加载器完成。
只有在父类记载其在iji的搜索范围内找不到指定的类时(classNotFoundException)

目的： 默认类库有的，会先用默认类库，安全，防止恶意加入混淆的类
确保一个类的全局唯一性
打破双亲委派机制不仅要继承ClassLoader类，还要重写LoadClass和findClass方法

先检查是否已经被加载过，若没有加载则调用父加载器的loadClass方法， 如父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException 异常后，再调用自己的findClass方法进行加载。