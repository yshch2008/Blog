---
date: "2019-4-30+08:00"
publishdate: "2019-4-30+08:00"
lastmod: "2019-4-30+08:00"
draft: false
title: "CAS操作原理与局限性"
tags: ["修行", "Java", "并发编程"]
series: ["技术"]
categories: ["学习"]
toc: true
---

---

`compareAndSwap` 
当前值有两份，一份在运行时缓存中，即线程当前可见的状态，称为期望值，仅自己可见；另一份在内存中，是真实值，其他线程可见。

顾名思义，执行赋值操作时，CAS过程包括判断-赋值两个阶段：
1. 判断期望值和内存值是否相等，若相等则认为该值未发生变动，在逻辑上没有脏写的危险，执行赋值操作，将内存值设置为新值（也叫目标值）；

2. 而如果不相等，则表明该资源存在竟态，在本CAS过程中有其他线程对资源进行了操作，发生了计划之外的变动，存在脏读脏写的风险，则放弃赋值操作。

最后将期望值更新为内存值，结束整个操作。



#### CAS操作存在的问题：

1. CAS如果长时间不成功，就会浪费掉非常多的CPU资源。
解决方法：pause指令。有两个作用:
a. 可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。
b. 可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

2. 只能保证一个共享变量的原子操作:当操作一个共享变量时，可以使用CAS，但一个原子操作有多个共享变量时。我们只能用锁来解决问题，获取把多个共享变量合并成一个共享变量。
解决方法：
a. 使用锁控制几个共享变量；
b. 合并几个共享变量使用CAS。

3. ABA风险
    1. 虽然内存值和期望值相同，但仍存在内存值被修改为其他值又被改回来的风险，这时理论上具有不同步的风险，但赋值操作仍会进行；
    2.  在自己操作内存时，会存在更大的风险——内存值存在的位置被赋予了其他的意义，而原先的内存值的地址已经被修改为另一个位置，那么对内存值的所有修改都不再可见，发生了逻辑上的误会。
    3. JAVA中不操作内存，则只有1风险，通过版本号解决，类似于幂等附加信息。